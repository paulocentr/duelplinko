# RNG and Commit-Reveal Analysis

## What Was Tested

- RNG depends only on disclosed inputs (server seed, client seed, nonce, cursor)
- Entropy sources are limited to the three-part seed system (no hidden randomness)
- Output uniformity: `value % 2` produces an unbiased 50/50 split
- Per-row independence: consecutive bounces are statistically independent
- Commit-reveal protocol: server seed commitment prevents post-bet manipulation

## What This Means for Players

Outcomes are generated from a cryptographically secure pseudorandom function. There are no hidden entropy sources (no timestamps, no `Math.random()`, no external APIs). Each bounce of the ball is independently random, and past bets do not influence future results. The casino commits to the server seed before any bets are placed, preventing outcome manipulation.

## Verdict Summary

| Component | Status | Finding |
|-----------|--------|---------|
| RNG derived only from disclosed inputs | ✅ Pass | No hidden randomness |
| Entropy purity | ✅ Pass | Three sources only: server seed, client seed, nonce |
| Output uniformity | ✅ Pass | Zero modulo bias for `value % 2` on uint32 |
| Per-row independence | ✅ Pass | Unique cursor per row; HMAC outputs are independent |
| Commit-reveal protocol | ✅ Pass | 24/24 seed commitments verified |

**Overall Verdict:** Unbiased and Cryptographically Sound

## Algorithm Specification

Duel.com's Plinko uses HMAC-SHA256 as its core random number generator. The algorithm computes one HMAC per row of the Plinko board, using a cursor value that increments with each row. This produces an independent pseudorandom value for each pin bounce.

### Inputs

The algorithm requires four inputs to produce a deterministic outcome:

| Input | Source | Purpose |
|-------|--------|---------|
| Server Seed | Generated by Duel.com (hex string, 64 chars) | Primary entropy source |
| Client Seed | Set by the player (alphanumeric string) | Player-contributed randomness |
| Nonce | Auto-incrementing integer (0, 1, 2, ...) | Ensures unique output per bet |
| Rows | Selected by player (8–16) | Determines number of bounces |

### Algorithm Steps

For each bet, the server executes the following procedure:

```javascript
function computePlinkoResult(serverSeed, clientSeed, nonce, rows) {
    // Decode server seed from hex to raw bytes
    const keyBytes = hexToBytes(serverSeed);  // CRITICAL: hex decode, not UTF-8

    let position = 0;

    for (let cursor = 0; cursor < rows; cursor++) {
        // Construct unique message for this row
        const message = `${clientSeed}:${nonce}:${cursor}`;

        // Compute HMAC-SHA256
        const hash = HMAC_SHA256(keyBytes, UTF8_encode(message));

        // Extract first 4 bytes as big-endian unsigned 32-bit integer
        const value = (hash[0] << 24 | hash[1] << 16 | hash[2] << 8 | hash[3]) >>> 0;

        // Determine bounce direction: 0 = left, 1 = right
        position += (value % 2);
    }

    return position;  // Final slot (0 to rows)
}
```

The final `position` value (ranging from 0 to `rows`) identifies which slot the ball lands in, and the corresponding multiplier from the risk-specific multiplier table is applied to determine the payout.

**[Evidence: E11, E27]**

## Critical Implementation Detail: Key Encoding

The most important implementation detail — and the one most likely to cause verification failures in third-party tools — is the **key encoding** for HMAC-SHA256.

The server seed is a 64-character hexadecimal string (e.g., `b6d2bb3df73995fd53a4f836b0db0e4b5ff61fec6155cda3d6e55d4bc866a585`). This string must be decoded into 32 raw bytes before use as the HMAC key:

```javascript
// CORRECT: Decode hex string to bytes
const keyBytes = hexToBytes(serverSeed);
// keyBytes.length === 32

// WRONG: Use string directly as UTF-8 bytes
const keyBytes = new TextEncoder().encode(serverSeed);
// keyBytes.length === 64 (each hex char becomes a byte)
```

Using the wrong encoding produces completely different HMAC outputs and will fail to reproduce the correct results. This detail is explicitly documented in Duel's fairness page code via the `hexToBytes()` helper function. **[Evidence: E34, E35]**

## Bias Analysis

### Modulo Bias Assessment

At each row, the algorithm computes `value % 2` where `value` is a 32-bit unsigned integer derived from the HMAC output. The question of modulo bias is relevant: does `value % 2` produce a perfectly uniform 50/50 split between 0 and 1?

For modulo 2, the answer is **yes — there is zero modulo bias**. The range of a 32-bit unsigned integer is 0 to 4,294,967,295 (2^32 - 1). Since 2^32 is exactly divisible by 2, there are precisely 2,147,483,648 values that produce remainder 0 and 2,147,483,648 values that produce remainder 1. The split is mathematically perfect.

This is in contrast to games that use `value % N` where N does not divide 2^32 evenly (e.g., `value % 52` for card games), which introduces a small bias that requires rejection sampling to correct. Duel's Plinko implementation avoids this issue entirely because the modulus is 2.

### HMAC Output Uniformity

HMAC-SHA256 is a pseudorandom function (PRF) that, given a secret key and a message, produces a 256-bit output that is computationally indistinguishable from random. The first 32 bits of this output, when interpreted as a uint32, are uniformly distributed over [0, 2^32 - 1].

Since each row uses a unique cursor value in the message (`clientSeed:nonce:0`, `clientSeed:nonce:1`, etc.), the HMAC outputs for different rows are statistically independent. There are no correlations between consecutive bounces.

### Resulting Distribution

With unbiased independent left-right decisions at each row, the final slot follows a **binomial distribution B(n, 0.5)** where n is the number of rows. The probability of landing in slot k (where k = 0, 1, ..., n) is:

```
P(slot = k) = C(n, k) / 2^n
```

For an 8-row board, this produces:

| Slot | Probability | Multiplier (Medium) |
|------|-------------|-------------------|
| 0    | 0.39%       | 13x               |
| 1    | 3.13%       | 3x                |
| 2    | 10.94%      | 1.3x              |
| 3    | 21.88%      | 0.7x              |
| 4    | 27.34%      | 0.4x              |
| 5    | 21.88%      | 0.7x              |
| 6    | 10.94%      | 1.3x              |
| 7    | 3.13%       | 3x                |
| 8    | 0.39%       | 13x               |

The distribution is symmetric, with the highest probability at the center (slot 4 for 8 rows) and decreasing probability toward the edges. This symmetry directly mirrors the visual layout of the Plinko board where multipliers increase toward the edges. **[Evidence: E06]**

## Per-Row Independence

Each row's bounce direction is computed from a unique HMAC invocation with a different cursor value. The HMAC messages for a bet with nonce 5 on an 8-row board would be:

```
Row 0: HMAC-SHA256(key, "ClientSeed:5:0")
Row 1: HMAC-SHA256(key, "ClientSeed:5:1")
Row 2: HMAC-SHA256(key, "ClientSeed:5:2")
...
Row 7: HMAC-SHA256(key, "ClientSeed:5:7")
```

Because HMAC-SHA256 is a PRF, knowing the output of one row's computation provides no information about the outputs of other rows. This means:

- The direction at row 3 does not depend on the direction at row 2
- Observing many bet outcomes does not help predict future outcomes (without knowing the server seed)
- Each bet is independent of all other bets (different nonce → different messages)

## Collision and Preimage Resistance

HMAC-SHA256 inherits the collision resistance of SHA-256. The probability of two different (clientSeed, nonce, cursor) tuples producing the same HMAC output is approximately 1 in 2^128 — effectively zero for any practical number of bets.

Preimage resistance means that given a target hash output, an attacker cannot efficiently find an input that produces it. For Duel's system, this means:

- **Players cannot choose a client seed** that forces a specific outcome (they would need to find a preimage of the HMAC, which is computationally infeasible)
- **The server cannot change the server seed** after committing its hash (finding a second preimage is infeasible)

These properties form the cryptographic backbone of the fairness guarantee.

## Commit-Reveal Protocol Assessment

The commit-reveal protocol operates as follows:

1. **Commit Phase**: Before the player places any bets, the server computes `hash = SHA-256(hexDecode(serverSeed))` and publishes this hash via the Provably Fair panel and in every API response.

2. **Betting Phase**: Bets are placed. Each bet uses the committed server seed, the player's client seed, and an incrementing nonce.

3. **Reveal Phase**: The player requests a seed rotation. The server reveals the plaintext server seed and commits to a new hash for the next segment.

4. **Verification Phase**: The player (or auditor) checks that `SHA-256(hexDecode(revealedSeed)) === committedHash` and recomputes all bet outcomes.

### Verification Results

We performed 24 seed rotations during our testing. Every rotation correctly revealed the server seed, and all 24 SHA-256 hash verifications passed:

```
Seed 1:  SHA-256(hexDecode("b6d2bb3d...")) === "5548792213..." ✓
Seed 2:  SHA-256(hexDecode("21fd096a...")) === "c1722335a7..." ✓
Seed 3:  SHA-256(hexDecode("add9684a...")) === "395af7ac85..." ✓
...
Seed 24: SHA-256(hexDecode("..."))          === "..."          ✓
```

All 24 commitments are intact. The server did not alter any seed after committing to its hash. **[Evidence: E29]**

### Comparison to Blockchain-Based Approaches

Some casinos (such as Luck.io on Solana) use on-chain VRF (Verifiable Random Functions) or commit-reveal with blockchain timestamps. Duel's approach differs:

| Property | Duel.com (HMAC-SHA256) | Blockchain VRF |
|----------|----------------------|----------------|
| Commit mechanism | SHA-256 hash published to client | Hash stored on-chain |
| Reveal mechanism | Server reveals on rotation | On-chain transaction |
| Re-rolling prevention | Hash commitment prevents changes | VRF proof prevents changes |
| Tamper evidence | Player must store committed hash | Blockchain stores immutably |
| Entropy source | Server PRNG (opaque) | VRF with public verification |

The key difference is **auditability of the commitment**. On a blockchain, the commitment is stored publicly and immutably. On Duel.com, the commitment is delivered to the player via API and displayed in the UI. If a player fails to record the committed hash before betting, they cannot retroactively prove what was committed. However, during the betting session itself, the commit-reveal protocol provides equivalent protection against outcome manipulation.

For the purpose of this audit, we recorded all committed hashes at the time of seed rotation, before any bets were placed with the new seeds. This allowed full retroactive verification of every bet in our dataset.

## Evidence Coverage

| Test | Source File | Status |
|------|------------|--------|
| RNG dependency verification | `PlinkoResultsGeneratorTests.ts` | ✅ Verified |
| Entropy purity (no hidden inputs) | `PlinkoResultsGeneratorTests.ts` | ✅ Verified |
| Unbiased mapping (`value % 2`) | `PlinkoGameProfilesTests.ts` | ✅ Verified |
| Per-row independence | `PlinkoAuditExecutionChecklistTests.ts` | ✅ Verified |
| HMAC key encoding (hexToBytes) | `PlinkoResultsGeneratorTests.ts` | ✅ Verified |
| Commit-reveal protocol | `PlinkoAuditExecutionChecklistTests.ts` | ✅ Verified |

**Code References:**
- Algorithm implementation: `src/plinko/PlinkoResultsGenerator.ts`
- Determinism test: `tests/plinko/PlinkoResultsGeneratorTests.ts`
- Seed verification: `tests/plinko/PlinkoAuditExecutionChecklistTests.ts`

**Dataset:** `duel-plinko-sim-1771364316980.json` (1,080 bets, 24 seed sessions)
