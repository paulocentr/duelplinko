# Exploit and Edge-Case Testing

## What Was Tested

We tested the Plinko implementation against known exploit categories from the ProvablyFair.org database of real-world provably fair failures:

- Outcome prediction before betting
- Post-bet result manipulation
- Seed lifecycle abuse
- Nonce reuse or desynchronization
- RNG bias exploitation
- Cross-bet and cross-user influence

## What This Means for Players

Outcomes cannot be predicted before placing a bet. Results cannot be altered after a bet is placed. No known exploit path exists that would give either the casino or the player an unfair advantage.

## Exploit Test Summary

| Category | Result | Finding |
|----------|--------|---------|
| Outcome prediction | ✅ PASS | HMAC-SHA256 is a PRF; server seed is hidden until rotation |
| Post-bet manipulation | ✅ PASS | Commit-reveal prevents re-rolling; 24/24 hashes verified |
| Seed lifecycle abuse | ✅ PASS | Hash committed before betting; revealed only on rotation |
| Nonce reuse or desync | ✅ PASS | 0 gaps, 0 duplicates across 24 segments (1,080 bets) |
| RNG bias exploitation | ✅ PASS | `value % 2` on uint32 has zero modulo bias |
| Cross-bet influence | ✅ PASS | Each bet uses unique (nonce, cursor) tuple; stateless RNG |

**Overall Verdict:** No exploitable vulnerabilities identified.

## What Constitutes an Exploit

| Type | Description | Beneficiary | Impact |
|------|-------------|-------------|--------|
| Outcome Prediction | Knowing result before bet is placed | Player | Casino loses revenue |
| Result Manipulation | Changing outcome after bet is placed | Casino | Players lose unfairly |
| Seed Leakage | Accessing unrevealed server seeds | Player | Predictable outcomes |
| Nonce Replay | Reusing nonce values for cherry-picking | Player | Selective win exploitation |
| RNG Bias | Non-uniform distribution favoring certain outcomes | Casino | Higher effective house edge |
| Verification Bypass | Preventing player from verifying outcomes | Casino | Undetectable manipulation |

## What Would Break Fairness

| Failure Mode | Impact | Detection Method | Result |
|--------------|--------|-----------------|--------|
| Server seed revealed before bet | Predictable outcomes | Timing analysis of API | No evidence of early reveal |
| Hash mismatch on reveal | Casino can swap seeds post-bet | Hash comparison | 24/24 hashes match |
| Nonce skip or reuse | Verification fails for affected bets | Sequence analysis | 0 gaps, 0 duplicates |
| Non-deterministic output | Cannot verify outcomes | Repeat testing with same inputs | 1,070/1,070 matches |
| Hidden entropy sources | Unverifiable randomness | Code audit of HMAC inputs | Only (serverSeed, clientSeed, nonce, cursor) used |
| Verifier differs from live | False sense of verification | Parity testing | 100% parity confirmed |

## Detailed Test Results

### 1. Outcome Prediction

**Attack vector:** If an attacker could predict the HMAC-SHA256 output before placing a bet, they could selectively bet on favorable outcomes.

**Why this fails:** The server seed is hidden — only its SHA-256 hash is published before betting. HMAC-SHA256 is a pseudorandom function; without the key (server seed), the output is computationally indistinguishable from random. The client seed and nonce are known, but without the server seed, the HMAC output cannot be predicted.

**Evidence:** The server seed is never exposed in API responses during active use. Only `server_seed_hashed` appears in bet responses. The plaintext seed is revealed only after rotation via `GET /api/v2/user/transactions/{id}`. **[Evidence: E12, E14, E17]**

### 2. Post-Bet Manipulation

**Attack vector:** The casino changes the server seed after seeing the player's bet to produce a losing outcome.

**Why this fails:** The server commits to the seed hash *before* any bets are placed. After 24 seed rotations, every revealed seed hashed to the previously committed value. Finding a second preimage (a different seed that produces the same hash) requires breaking SHA-256, which is computationally infeasible.

**Verification:**

```
Seed  1: SHA-256(hexDecode("b6d2bb3d...")) = "55487922..." ✓
Seed  2: SHA-256(hexDecode("21fd096a...")) = "c1722335..." ✓
...
Seed 24: SHA-256(hexDecode("..."))          = "..."        ✓

Result: 24/24 commitments verified
```

**[Evidence: E29]**

### 3. Seed Lifecycle Abuse

**Attack vector:** The casino reveals the seed prematurely, reuses seeds across sessions, or delays rotation to accumulate favorable outcomes.

**Testing approach:**
- Confirmed seed hash is present in the *first* bet response of each segment (commitment exists before betting)
- Confirmed each rotation produces a *new* server seed hash (no seed reuse)
- Confirmed rotation correctly reveals the previous seed and commits to a new one
- Confirmed nonce resets to 0 after each rotation

**Result:** The seed lifecycle follows the expected commit → bet → rotate → reveal → verify pattern with no anomalies across 24 rotations. **[Evidence: E12, E26, E29]**

### 4. Nonce Reuse or Desynchronization

**Attack vector:** If nonces are reused, the casino could replay favorable outcomes. If nonces are skipped, bets may have been inserted or removed.

**Testing approach:** We analyzed all 1,080 bets across 24 seed segments:

| Metric | Result |
|--------|--------|
| Seed segments analyzed | 24 |
| Total bets | 1,080 |
| Nonce gaps | **0** |
| Nonce duplicates | **0** |
| Out-of-order nonces | **0** |
| Nonce reset on rotation | **Yes** (all 24 segments start at 0) |

Each segment shows strictly sequential nonces starting from 0. This eliminates bet insertion, bet removal, bet replay, and selective disclosure attacks. **[Evidence: E30, E39]**

### 5. RNG Bias Exploitation

**Attack vector:** If the RNG produces a non-uniform distribution, the casino could have a higher effective house edge than advertised.

**Testing approach:**
- **Modulo bias:** `value % 2` where `value` is uint32 has mathematically zero bias (2^32 is exactly divisible by 2)
- **HMAC uniformity:** HMAC-SHA256 output is computationally indistinguishable from random
- **Chi-squared tests:** All 9 row configurations pass goodness-of-fit at p=0.05 against B(n, 0.5)
- **Edge slot analysis:** Observed edge-slot frequencies are consistent with expected binomial probabilities

**Result:** No statistical evidence of bias in any configuration. The closest chi-squared result (8 rows: 14.827 vs critical 15.507) is still a clear pass and is driven by edge-slot volatility where expected counts are below 1. **[Evidence: E36, E37]**

### 6. Cross-Bet and Cross-User Influence

**Attack vector:** The outcome of one bet influences subsequent bets, or one user's bets affect another user's outcomes.

**Why this fails:**
- The HMAC function is stateless — it takes `(key, message)` and returns a deterministic output with no side effects
- Each bet uses a unique message: `"${clientSeed}:${nonce}:${cursor}"`. Different nonces produce independent outputs
- Different users have different server seeds, so their outcome spaces are entirely separate
- Within a bet, each row uses a different cursor value, producing independent per-row outcomes

**Verification:** Our 1,070 verified bets confirm that the same inputs always produce the same output, and different inputs (different nonces) produce statistically independent outputs as demonstrated by the chi-squared tests. **[Evidence: E27, E28, E36]**

## Exploit Reference Framework

This testing follows the ProvablyFair.org exploit classification system, which catalogs real-world failures observed across provably fair implementations. Common failure patterns include:

- **Incorrect seed lifecycle:** Server seed revealed before bet settlement (seen in early Bitcoin dice sites)
- **Nonce management failures:** Nonce reuse, gaps, or non-sequential ordering (enables replay attacks)
- **Mixed entropy:** Hidden entropy sources (timestamps, Math.random()) mixed into supposedly deterministic outputs
- **Stateful RNG:** RNG that carries state between bets, enabling correlation attacks
- **Hash implementation errors:** Wrong encoding (UTF-8 vs hex bytes), wrong hash function, truncation errors
- **Verification bypass:** Verifier uses different logic than the live game, giving false confidence

Duel's Plinko implementation avoids all of these failure patterns. The algorithm is simple (HMAC-SHA256 with per-row cursor), the seed lifecycle is clean, and the nonce management is correct.

## Evidence Coverage

| Test | Source File | Status |
|------|------------|--------|
| Seed commitment verification | `PlinkoAuditExecutionChecklistTests.ts` | ✅ Verified |
| Nonce sequence analysis | `PlinkoAuditExecutionChecklistTests.ts` | ✅ Verified |
| Deterministic parity (1,070 bets) | `PlinkoResultsGeneratorTests.ts` | ✅ Verified |
| Chi-squared goodness-of-fit | `PlinkoAuditExecutionChecklistTests.ts` | ✅ Verified |
| Multiplier consistency | `PlinkoAuditExecutionChecklistTests.ts` | ✅ Verified |
| Payout accuracy | `PlinkoWinCalculatorTests.ts` | ✅ Verified |

**Dataset:** `duel-plinko-sim-1771364316980.json` (1,080 bets, 24 seed sessions)
